<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>MLIR.AST.Dialect.Tensor</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">mlir-hs-0.1.0.0</span><ul class="links" id="page-menu"><li><a href="src/MLIR.AST.Dialect.Tensor.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">MLIR.AST.Dialect.Tensor</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">cast</a></li><li><a href="#g:2">collapse_shape</a></li><li><a href="#g:3">dim</a></li><li><a href="#g:4">expand_shape</a></li><li><a href="#g:5">extract</a></li><li><a href="#g:6">extract_slice</a></li><li><a href="#g:7">from_elements</a></li><li><a href="#g:8">generate</a></li><li><a href="#g:9">insert</a></li><li><a href="#g:10">insert_slice</a></li><li><a href="#g:11">pad</a></li><li><a href="#g:12">rank</a></li><li><a href="#g:13">reshape</a></li><li><a href="#g:14">splat</a></li><li><a href="#g:15">yield</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">pattern</span> <a href="#v:Cast">Cast</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:cast">cast</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Dim">Dim</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:dim">dim</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:extract">extract</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:extract_slice">extract_slice</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:FromElements">FromElements</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; [operand] -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:from_elements">from_elements</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:generate">generate</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:insert">insert</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:insert_slice">insert_slice</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:pad">pad</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Rank">Rank</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:rank">rank</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Reshape">Reshape</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:reshape">reshape</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Splat">Splat</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:splat">splat</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Yield">Yield</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:yield">yield</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>cast</h1></a><div class="doc"><p>Convert a tensor from one type to an equivalent type without changing any
 data elements. The source and destination types must both be tensor types
 with the same element type. If both are ranked, then the rank should be the
 same and static dimensions should match. The operation is invalid if
 converting to a mismatching constant dimension.</p><p>Example:</p><pre>// Convert from unknown rank to rank 2 with unknown dimension sizes.
%2 = tensor.cast %1 : tensor&lt;*xf32&gt; to tensor&lt;?x?xf32&gt;

// Convert to a type with more known dimensions.
%3 = tensor.cast %2 : tensor&lt;?x?xf32&gt; to tensor&lt;4x?xf32&gt;

// Discard static dimension and rank information.
%4 = tensor.cast %3 : tensor&lt;4x?xf32&gt; to tensor&lt;?x?xf32&gt;
%5 = tensor.cast %4 : tensor&lt;?x?xf32&gt; to tensor&lt;*xf32&gt;
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Cast" class="def">Cast</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#Cast" class="link">Source</a> <a href="#v:Cast" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>tensor.cast</code>.</p></div></div><div class="top"><p class="src"><a id="v:cast" class="def">cast</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#cast" class="link">Source</a> <a href="#v:cast" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.cast</code>.</p></div></div><a href="#g:2" id="g:2"><h1>collapse_shape</h1></a><div class="doc"><p>The <code>tensor.collapse_shape</code> op produces a new tensor with a smaller
 rank whose sizes are a reassociation of the original <code>src</code>.</p><p>A reassociation is defined as a continuous grouping of dimensions and is
 represented with an array of I64ArrayAttr attribute.</p><p>The verification rule is that the reassociation maps are applied to the
 operand tensor with the higher rank to obtain the result tensor with the
 smaller rank.</p><p>The result tensor type of a reshape can be zero-ranked if the operand
 tensor type is statically shaped with all dimensions being unit extent. In
 such case the reassociation map is empty.</p><p>Examples:</p><pre>// Dimension collapse (i, j) -&gt; i' and k -&gt; k'
%b = tensor.collapse_shape %a [[0, 1], [2]]
    : tensor&lt;?x?x?xf32&gt; into tensor&lt;?x?xf32&gt;
</pre></div><a href="#g:3" id="g:3"><h1>dim</h1></a><div class="doc"><p>The <code>tensor.dim</code> operation takes a tensor and a dimension operand of type
 <code>index</code>. It returns the size of the requested dimension of the given
 tensor. If the dimension index is out of bounds, the behavior is undefined.</p><p>The specified tensor type is that of the first operand.</p><p>Example:</p><pre>// Always returns 4, can be constant folded:
%c0 = arith.constant 0 : index
%x = tensor.dim %A, %c0 : tensor&lt;4x?xf32&gt;

// Returns the dynamic dimension of %A.
%c1 = arith.constant 1 : index
%y = tensor.dim %A, %c1 : memref&lt;4x?xf32&gt;

// Equivalent generic form:
%x = &quot;tensor.dim&quot;(%A, %c0) : (memref&lt;4x?xf32&gt;, index) -&gt; index
%y = &quot;tensor.dim&quot;(%A, %c1) : (memref&lt;4x?xf32&gt;, index) -&gt; index
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Dim" class="def">Dim</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#Dim" class="link">Source</a> <a href="#v:Dim" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>tensor.dim</code>.</p></div></div><div class="top"><p class="src"><a id="v:dim" class="def">dim</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#dim" class="link">Source</a> <a href="#v:dim" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.dim</code>.</p></div></div><a href="#g:4" id="g:4"><h1>expand_shape</h1></a><div class="doc"><p>The <code>tensor.expand_shape</code> op produces a new tensor with a higher
 rank whose sizes are a reassociation of the original <code>src</code>.</p><p>A reassociation is defined as a continuous grouping of dimensions and is
 represented with an array of I64ArrayAttr attribute.</p><p>The verification rule is that the reassociation maps are applied to the
 result tensor with the higher rank to obtain the operand tensor with the
 smaller rank.</p><p>The operand tensor type of a reshape can be zero-ranked if the result
 tensor type is statically shaped with all dimensions being unit extent. In
 such cases the reassociation map is empty.</p><p>Examples:</p><pre>// Dimension expansion i -&gt; (i', j') and (k) -&gt; (k')
%b = tensor.expand_shape %a [[0, 1], [2]]
    : tensor&lt;?x?xf32&gt; into tensor&lt;?x?x?xf32&gt;
</pre></div><a href="#g:5" id="g:5"><h1>extract</h1></a><div class="doc"><p>The <code>tensor.extract</code> op reads a tensor and returns one
 element from it specified by an index list. The output of the op is a
 new value with the same type as the elements of the tensor. The
 arity of indices must match the rank of the accessed value (i.e., if a
 tensor is of rank 3, then 3 indices are required for the extract. The
 indices should all be of <code>index</code> type.</p><p>Example:</p><pre>%4 = tensor.extract %t[%1, %2] : tensor&lt;4x4xi32&gt;
%5 = tensor.extract %rt[%1, %2] : tensor&lt;?x?xi32&gt;
%6 = tensor.extract %ut[%1, %2] : tensor&lt;*xi32&gt;
</pre></div><div class="top"><p class="src"><a id="v:extract" class="def">extract</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#extract" class="link">Source</a> <a href="#v:extract" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.extract</code>.</p></div></div><a href="#g:6" id="g:6"><h1>extract_slice</h1></a><div class="doc"><p>The &quot;extract_slice&quot; operation extract a tensor from another tensor as
 specified by the operation's offsets, sizes and strides arguments.</p><p>The extract_slice operation supports the following arguments:</p><ul><li>source: the &quot;base&quot; tensor from which to extract a slice.</li><li>offsets: tensor-rank number of offsets into the &quot;base&quot; tensor from which
            to extract the slice.</li><li>sizes: tensor-rank number of sizes which specify the sizes of the result
          tensor type.</li><li>strides: tensor-rank number of strides specifying subsampling in each
            dimension.</li></ul><p>The representation based on offsets, sizes and strides support a
 partially-static specification via attributes specified through the
 <code>static_offsets</code>, <code>static_sizes</code> and <code>static_strides</code> arguments. A special
 sentinel value ShapedType::kDynamicSize and
 ShapedType::kDynamicStrideOrOffset encodes that the corresponding entry has
 a dynamic value.</p><p>After buffer allocation, the &quot;extract_slice&quot; op is expected to lower into a
 memref.subview op.</p><p>An extract_slice operation may additionally reduce the rank of the resulting
 tensor by removing dimensions that are statically known to be of size 1.
 This rank-reduction behavior is not required by the op semantics: this
 flexibility allows to progressively drop unit dimensions while lowering
 between different flavors of ops on that operate on tensors.</p><p>Example:</p><pre>// Rank-reducing extract_slice.
%1 = tensor.extract_slice %0[0, 0, 0][1, 16, 4][1, 1, 1] :
  tensor&lt;8x16x4xf32&gt; to tensor&lt;16x4xf32&gt;
%3 = tensor.extract_slice %2[%o0, 4, %o2][1, %sz1, 1][1, %st1, 1] :
  tensor&lt;8x16x4xf32&gt; to tensor&lt;1x?xf32&gt;
</pre></div><div class="top"><p class="src"><a id="v:extract_slice" class="def">extract_slice</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#extract_slice" class="link">Source</a> <a href="#v:extract_slice" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.extract_slice</code>.</p></div></div><a href="#g:7" id="g:7"><h1>from_elements</h1></a><div class="doc"><p>Create a N-D tensor from a range of same-type arguments. The number of
 provided <code>elements</code> should equal to the number of the elements in the
 result type. The <code>elements</code> correspond to a flattened tensor.</p><p>Example:</p><pre>tensor.from_elements %a, %b, %c, %d, %e, %f :  tensor&lt;2x3xindex&gt;
</pre><p>will result in a tensor</p><dl><dt>[%a, %b, %c</dt><dd></dd><dt>%d, %e, %f</dt><dd>]</dd></dl></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:FromElements" class="def">FromElements</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; [operand] -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#FromElements" class="link">Source</a> <a href="#v:FromElements" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>tensor.from_elements</code>.</p></div></div><div class="top"><p class="src"><a id="v:from_elements" class="def">from_elements</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#from_elements" class="link">Source</a> <a href="#v:from_elements" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.from_elements</code>.</p></div></div><a href="#g:8" id="g:8"><h1>generate</h1></a><div class="doc"><p>This operation creates a dynamically sized tensor with elements of any type.
 It expects one index operand per dynamic extent of the result tensor.</p><p>The body region defines the tensor's elements. It takes index operands as
 its region arguments that span the index space. The element at the given
 position is yielded with the <code>yield</code> operation (see <code>YieldOp</code>). There is
 no defined ordering to the invocations of the body. It is conceptually
 a &quot;parallel map&quot; operation.</p><p>Example:</p><pre>  %tnsr = tensor.generate %m, %n {
  ^bb0(%i : index, %j : index, %k : index):
    ...
    yield %elem : f32
  } : tensor&lt;?x3x?f32&gt;
</pre></div><div class="top"><p class="src"><a id="v:generate" class="def">generate</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#generate" class="link">Source</a> <a href="#v:generate" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.generate</code>.</p></div></div><a href="#g:9" id="g:9"><h1>insert</h1></a><div class="doc"><p>The <code>tensor.insert</code> op writes a tensor into a tensor <code>dest</code>as specified by
 the operation's indices.</p><p>It returns a copy of <code>dest</code> with the proper slice updated with the value
 of <code>scalar</code>.</p><p>The arity of indices must match the rank of the tensor <code>dest</code> (i.e., if a
 tensor is of rank 3, then 3 indices are required for the extract. The
 indices should all be of <code>index</code> type.</p><p>Example:</p><pre>%4 = tensor.insert %t into %dest[%1, %2] : tensor&lt;4x4xi32&gt;
%5 = tensor.insert %rt into %dest[%1, %2] : tensor&lt;?x?xi32&gt;
%6 = tensor.insert %ut into %dest[%1, %2] : tensor&lt;*xi32&gt;
</pre></div><div class="top"><p class="src"><a id="v:insert" class="def">insert</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#insert" class="link">Source</a> <a href="#v:insert" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.insert</code>.</p></div></div><a href="#g:10" id="g:10"><h1>insert_slice</h1></a><div class="doc"><p>The &quot;insert_slice&quot; operation insert a tensor <code>source</code> into another
 tensor <code>dest</code> as specified by the operation's offsets, sizes and strides
 arguments.</p><p>It returns a copy of <code>dest</code> with the proper slice updated with the value
 of <code>source</code>.</p><p>The insert_slice operation supports the following arguments:</p><ul><li>source: the tensor that is inserted.</li><li>dest: the tensor into which the source tensor is inserted.</li><li>offsets: tensor-rank number of offsets into the <code>dest</code> tensor into which
            the slice is inserted.</li><li>sizes: tensor-rank number of sizes which specify the sizes of the result
          tensor type.</li><li>strides: tensor-rank number of strides that specify subsampling in each
            dimension.</li></ul><p>The representation based on offsets, sizes and strides support a
 partially-static specification via attributes specified through the
 <code>static_offsets</code>, <code>static_sizes</code> and <code>static_strides</code> arguments. A special
 sentinel value ShapedType::kDynamicSize and
 ShapedType::kDynamicStrideOrOffset encodes that the corresponding entry has
 a dynamic value.</p><p>After buffer allocation, the &quot;insert_slice&quot; op is expected to lower into a
 memref.subview op.</p><p>An insert_slice operation may additionally specify insertion into a tensor
 of higher rank than the source tensor, along dimensions that are statically
 known to be of size 1.
 This rank-altering behavior is not required by the op semantics: this
 flexibility allows to progressively drop unit dimensions while lowering
 between different flavors of ops on that operate on tensors.
 The rank-altering behavior of tensor.insert_slice matches the rank-reducing
 behavior of tensor.extract_slice.</p><p>Example:</p><pre>// Rank-reducing extract_slice.
%1 = tensor.insert_slice %t into %0[0, 0, 0][1, 16, 4][1, 1, 1] :
  tensor&lt;16x4xf32&gt; into tensor&lt;8x16x4xf32&gt;
%3 = tensor.insert_slice %tt into %2[%o0, 4, %o2][1, %sz1, 1][1, %st1, 1] :
  tensor&lt;1x?xf32&gt; into tensor&lt;8x16x4xf32&gt;
</pre></div><div class="top"><p class="src"><a id="v:insert_slice" class="def">insert_slice</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#insert_slice" class="link">Source</a> <a href="#v:insert_slice" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.insert_slice</code>.</p></div></div><a href="#g:11" id="g:11"><h1>pad</h1></a><div class="doc"><p><code>tensor.pad</code> is an operation that pads the <code>source</code> tensor
 with given <code>low</code> and <code>high</code> padding config.</p><p>The PadOp operation supports the following arguments:</p><ul><li>source: the &quot;base&quot; tensor on which to pad.</li><li>low: A list contains the padding along the start of each
        dimension, i.e <code>low</code>.</li><li>high: A list contains the padding along the end of each
         dimension, i.e. <code>high</code>.</li><li>nofold: indicates that the operation should not be folded when source and
           result types are equal.</li></ul><p>The result tensor dimensions are <code>low</code> + <code>dim</code> + <code>high</code> along that
 dimension. The number of elements of <code>low</code> and <code>high</code> must match
 the rank of the input tensor. They can be either a constant or a
 dynamic value.</p><p>The region of the <code>tensor.pad</code> operation returns the value to use
 for the padding. The arguments of the region represent the index
 of the source being accessed. There should be as many arguments as
 the rank of the <code>source</code> tensor. The value <code>yield</code>-ed by the
 region is used as the value of the view at the given position.</p><p>If <code>nofold</code> is set, the padding operation will not be folded away even
 if the source type and the padded type have the same static shape. This can
 be used, e.g., for packing or promotion to faster memory.</p><p>Example 1:</p><pre>  %pad_value = ... : f32
  %0 = tensor.pad %0 low[1, 2] high[2, 3] {
  ^bb0(%arg0 : index, %arg1 : index):
    tensor.yield %pad_value : f32
  } : tensor&lt;?x?xf32&gt; to tensor&lt;?x?xf32&gt;
</pre><p>Example 2:</p><pre>  %pad_value = ... : f32
  %0 = tensor.pad %arg0 low[2, %arg1, 3, 3] high[3, 3, %arg1, 2] {
  ^bb0(%arg2: index, %arg3: index, %arg4: index, %arg5: index):
      tensor.yield %pad_value : f32
  } : tensor&lt;1x2x2x?xf32&gt; to tensor&lt;6x?x?x?xf32&gt;
</pre><p>Example 3:</p><pre>  %pad_value = ... : f32
  %0 = tensor.pad %arg0 low[0, 0] high[%ub0, %ub1] {
  ^bb0(%arg1: index, %arg2: index):
    tensor.yield %pad_value : f32
  } : tensor&lt;2x3xf32&gt; to tensor&lt;?x?xf32&gt;
</pre><p>Example 4:</p><pre>  // Force a padded value to be always exist with <code>nofold</code>.
  %pad_value = ... : f32
  %0 = tensor.pad %arg0 nofold low[0, 0] high[0, 0] {
  ^bb0(%arg1: index, %arg2: index):
    tensor.yield %pad_value : f32
  } : tensor&lt;2x3xf32&gt; to tensor&lt;2x3xf32&gt;
</pre></div><div class="top"><p class="src"><a id="v:pad" class="def">pad</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; [<a href="../base-4.14.1.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#pad" class="link">Source</a> <a href="#v:pad" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.pad</code>.</p></div></div><a href="#g:12" id="g:12"><h1>rank</h1></a><div class="doc"><p>The <code>tensor.rank</code> operation takes a tensor operand and returns its rank.</p><p>Example:</p><pre>%0 = tensor.rank %arg0 : tensor&lt;*xf32&gt;
%1 = tensor.rank %arg1 : tensor&lt;?x?xf32&gt;
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Rank" class="def">Rank</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#Rank" class="link">Source</a> <a href="#v:Rank" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>tensor.rank</code>.</p></div></div><div class="top"><p class="src"><a id="v:rank" class="def">rank</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#rank" class="link">Source</a> <a href="#v:rank" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.rank</code>.</p></div></div><a href="#g:13" id="g:13"><h1>reshape</h1></a><div class="doc"><p>The <code>reshape</code> operation converts a tensor from one type to an equivalent
 type with a provided shape. The source and destination types are compatible
 if both have the same element type, same number of elements. The following
 combinations are possible:</p><p>a. Source type is ranked or unranked. Shape argument has static size.
 Result type is ranked.</p><pre>// Reshape statically-shaped tensor.
%dst = tensor.reshape %src(%shape)
         : (tensor&lt;4x1xf32&gt;, tensor&lt;1xi32&gt;) -&gt; tensor&lt;4xf32&gt;
%dst0 = tensor.reshape %src(%shape0)
         : (tensor&lt;4x1xf32&gt;, tensor&lt;2xi32&gt;) -&gt; tensor&lt;2x2xf32&gt;
// Flatten unranked tensor.
%dst = tensor.reshape %src(%shape)
         : (tensor&lt;*xf32&gt;, tensor&lt;1xi32&gt;) -&gt; tensor&lt;?xf32&gt;
</pre><p>b. Source type is ranked or unranked. Shape argument has dynamic size.
 Result type is unranked.</p><pre>// Reshape dynamically-shaped 1D tensor.
%dst = tensor.reshape %src(%shape)
         : (tensor&lt;?xf32&gt;, tensor&lt;?xi32&gt;) -&gt; tensor&lt;*xf32&gt;
// Reshape unranked tensor.
%dst = tensor.reshape %src(%shape)
         : (tensor&lt;*xf32&gt;, tensor&lt;?xi32&gt;) -&gt; tensor&lt;*xf32&gt;
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Reshape" class="def">Reshape</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#Reshape" class="link">Source</a> <a href="#v:Reshape" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>tensor.reshape</code>.</p></div></div><div class="top"><p class="src"><a id="v:reshape" class="def">reshape</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#reshape" class="link">Source</a> <a href="#v:reshape" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.reshape</code>.</p></div></div><a href="#g:14" id="g:14"><h1>splat</h1></a><div class="doc"><p>Broadcast the operand to all elements of the result tensor. The operand is
 required to be of integer<em>index</em>float type, and the result tensor must be
 statically shaped.</p><p>Example:</p><pre>%s = arith.constant 10.1 : f32
%t = tensor.splat %s : tensor&lt;8x16xi32&gt;
</pre><p>TODO: This operation is easy to extend to broadcast to dynamically shaped
       tensors:</p><pre>// Broadcasts %s to a 2-d dynamically shaped tensor, with %m, %n binding
// to the sizes of the two dynamic dimensions.
%m = &quot;foo&quot;() : () -&gt; (index)
%n = &quot;bar&quot;() : () -&gt; (index)
%t = tensor.splat %s [%m, %n] : tensor&lt;?x?xi32&gt;
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Splat" class="def">Splat</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#Splat" class="link">Source</a> <a href="#v:Splat" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>tensor.splat</code>.</p></div></div><div class="top"><p class="src"><a id="v:splat" class="def">splat</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#splat" class="link">Source</a> <a href="#v:splat" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.splat</code>.</p></div></div><a href="#g:15" id="g:15"><h1>yield</h1></a><div class="doc"><p>This operation is used to yield a single value from a within a region. It
 is used to create dynamically sized tensors
 (see <code>tensor.generate</code> and <code>tensor.pad</code> ops).</p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Yield" class="def">Yield</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#Yield" class="link">Source</a> <a href="#v:Yield" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>tensor.yield</code>.</p></div></div><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a> <a href="src/MLIR.AST.Dialect.Generated.Tensor.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><p>A builder for <code>tensor.yield</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>